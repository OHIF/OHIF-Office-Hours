# OHIF Office Hours Notes 2025-11-25

## Q & A

attendees: 11

## One-line summaries

- üß© Best format for storing large multi-label DICOM segmentations and what compression paths OHIF will support next.
- üé® How to control annotation styling, units and which statistics appear when building a 3.10 extension.
- ‚úÇÔ∏è Status and direction for the new volume-cropping interface.
- üèóÔ∏è How to structure organization-specific logic so upgrades between OHIF versions stay painless.
- üõ†Ô∏è How to show or hide specific toolbar tools based on imaging modality.

## QA


---

**Q:** I have a question about DICOM segmentation files and the best format to save and load DICOM segmentation with 100 different labels. Do you plan to support JPEG2000Lossless or RLELossless? What is best in terms of loading time, Labelmap or Binary?

**A:**
If your 100 segments never overlap and each voxel belongs to a single label, use the new DICOM Labelmap IOD instead of DICOM SEG. That is what OHIF targets for non overlapping segmentations and it keeps the decoding logic simpler on the viewer side.

Highdicom is the right library to generate these objects. If you see a size jump, for example from 7 MB (binary) to about 31 MB (labelmap), that is still reasonable. If it looks off, raise it with the highdicom maintainers so they can confirm whether your encoder is configured correctly.

Today OHIF reads uncompressed labelmaps and does not yet support encoded labelmaps for segmentation. For transport you can already use deflated explicit VR little endian (the ‚Äú.99‚Äù transfer syntax) because OHIF inflates that at parse time. The standard also recently added a GZIP based image frame compression transfer syntax specifically aimed at labelmaps, and we intend to support it once the implementation is in place. When we do add compressed labelmap support, we expect to favor RLE Lossless or JPEG LS over JPEG 2000, because JPEG 2000 decoding is slow for volume data. If this matters to you, open an issue on GitHub so others can upvote it and help us prioritize.

---

**Q:** How can I configure annotation styling, measurement units, and displayed statistics in a custom OHIF 3.10 extension?

**A:**

**Annotation styling**
Cornerstone Tools exposes a styling API for annotations. You can:

* Set global defaults in your extension‚Äôs init code (preRegistration) using the Cornerstone Tools style helpers.
* In newer OHIF versions there is an `updateMeasurement` command that takes a measurement UID and a `style` object and applies it to that single measurement. If you are on 3.10, you can copy that command from 3.12 into your project and call it from your extension.

The reference docs for annotation styling are here:
[https://www.cornerstonejs.org/docs/concepts/cornerstone-tools/annotation/config/](https://www.cornerstonejs.org/docs/concepts/cornerstone-tools/annotation/config/)

For overall theming (colors, typography) OHIF 3.10 uses Tailwind tokens defined in the platform app `tailwind.config`. Primary, background and other tokens are mapped to CSS variables, and you can tune those to match your brand palette. See the colors and type guide:
[https://docs.ohif.org/colors-and-type/](https://docs.ohif.org/colors-and-type/)

**Units and which statistics appear**
Units and displayed statistics are wired through the customization service:

* OHIF exposes a `cornerstoneMeasurements` customization hook where you can specify which statistics appear for each tool and how they are labeled.
* The docs are here:
  [https://docs.ohif.org/platform/services/customization-service/measurements/#cornerstonemeasurements](https://docs.ohif.org/platform/services/customization-service/measurements/#cornerstonemeasurements)

For example, you can configure planar freehand ROI to output only mean, max and area and omit other fields from the measurement display and exports.

At the moment there is a bug in 3.10 that affects this configuration in some cases. Until that is fixed, there is a workaround:

* Each tool mapping file, such as `extensions/cornerstone/src/utils/measurementServiceMappings/PlanarFreehandROI.ts`, has a `getDisplayText` function.
* You can edit `getDisplayText` directly to control exactly which statistics appear (for example, remove min and standard deviation, only show mean and area).

This is not as clean as using the customization service, but it gives you precise control today.

---

**Q:** Volume cropping user interface.

**A:**
We have started iterating on the volume cropping tool UI together with Martin. The plan is to refine the interaction design and iconography based on real use cases, then fold that back into the core layout once the UX is validated. We will share more details and visuals in a future session once the design stabilizes.

---


**Q:** I am using OHIF 3.10. What is an appropriate way to store organization specific artifacts so they are easy to port to newer OHIF versions? Should they live in a new custom extension or in a folder at the root of OHIF? We have also added a few components to the SR extension and updated existing components. How should we handle this when upgrading?

**A:**
The short answer: keep organization specific logic in your own extension, not in `platform/*`, whenever possible.

**General guidance**

* Put workflow specific UI, layouts, toolbar configuration, enums, CSS and custom services into a single ‚Äúenterprise‚Äù extension.
* Avoid modifying `platform/app`, `platform/core` or the built in extensions unless you have a very strong reason. Every direct change there will create merge conflicts on each OHIF upgrade.
* If you need changes that are generally useful, contribute them upstream as a PR so you do not have to maintain a long term patch.

**Custom layouts, toolbars and icons**

* Modes are very thin; they mostly choose which layout and toolbar to use.
* You can export a `getLayoutTemplateModule` from your own extension and have a mode use your layout instead of the default viewer layout. That gives you full control over header position, toolbar placement, side panels and viewport grid.
* For toolbar buttons, your extension can provide its own `getToolbarModule`. There you can:

  * Define your own button list.
  * Swap icons by registering new React SVG icons with `icons.addIcon` in your extension‚Äôs initialization and referencing them by name in the toolbar config.

**Shared logic and services**

* If multiple organization extensions really depend on the same logic, you can either:

  * Keep everything in a single extension, which is simpler to manage today.
  * Or factor out pure utility functions that other extensions import directly.
* For stateful behavior, register services in your extension and access them through the `servicesManager` rather than importing state across extensions. This keeps the architecture clean and avoids tight coupling.

Right now there is no strong benefit in splitting a tightly coupled set of organization specific features into several extensions, so a single well structured enterprise extension is usually the most maintainable approach.

---

**Q:** How can I configure the OHIF toolbar so that certain tools (for example, the Swivel tool) are only shown when viewing CT images and hidden for other modalities? Currently we can only disable when the modality is not supported.

**A:**
Toolbar behavior is driven by ‚Äúevaluators‚Äù on each toolbar item. OHIF already ships an evaluator that checks the current modality, and you can add more.

**Modality based enable / disable**

* In the toolbar config (for example in the basic toolbar module) each button can define an `evaluate` field.
* The built in `evaluateModalitySupported` evaluator reads the series‚Äô modality and decides whether the tool should be enabled.
* The ‚ÄúUltrasound Directional‚Äù tool in the public viewer is an example: it only enables when the current series is ultrasound.

You can write your own evaluators too. Evaluators are just functions that receive the current context and return the button state, so you can base them on anything you need: series type, viewport, hanging protocol and so on.

**Hiding instead of disabling**

There is a `hideWhenDisabled` flag on toolbar buttons that is intended to hide a tool completely when evaluators mark it as disabled. In the current code that behavior is not working correctly and we opened a ticket to fix it. Once that is resolved you will be able to:

* Use `evaluateModalitySupported` to mark tools disabled for non supported modalities.
* Set `hideWhenDisabled: true` to hide them entirely in those cases.

Until that fix lands, the tool will be disabled rather than hidden. If you need stronger guarantees right now, you can create a custom evaluator that directly returns ‚Äúhidden‚Äù for non supported modalities and wire that into your extension‚Äôs toolbar module.

